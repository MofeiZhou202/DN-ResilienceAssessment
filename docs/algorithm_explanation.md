# 推理层算法说明（傻瓜式版）

## 一句话总结

> **推理层的目标**：不跑Julia优化（每条线路5-15分钟），只用Python在几秒内预测——"如果加固这条线路，配电网的失负荷和超时节点能改善多少百分比？"
> 然后把35条线路按改善率排序，告诉你该优先修哪条。

---

## 网络模型

```
配电网 = 30个节点(25个AC母线 + 5个DC母线) + 35条线路
  ├─ 26条AC线路 (Cable1~26)，其中Cable24/25/26是常开联络开关
  ├─ 2条DC线路 (DCLine1~2)
  └─ 7条VSC换流器 (VSC1~7)，桥接AC↔DC网络，其中VSC1/3常开
```

另外还有 **3台MESS移动储能**（可以在交通网络上移动到不同母线注入功率）。

---

## 数据来源

Monte Carlo仿真数据：
- **100个台风场景** × **35条线路** = 3500行故障矩阵
- 每行48个时间步（每步30分钟，共24小时）的线路状态（1=正常，0=故障）
- 对应的Julia MILP优化结果：每个时间步的失负荷、供电率、超时节点数

---

## 核心问题：为什么主干线路（骨干线路）反而有"更多缓解手段"？

### 什么是"主干线路"（关键瓶颈线路）？

判定条件：**BC > 0.08** 或 **孤立负荷比例 > 20%**

- **BC (Betweenness Centrality)** = 介数中心性，衡量一条线路在多少"最短路径"上。
  - BC高 → 这条线路连接了网络的多个部分，是"交通要道"
  - BC低 → 这条线路是末梢分支，只连接少量负荷

- **孤立负荷比例** = 如果移除该线路后，有多少负荷和电源断开

### 直觉解释

想象一棵树：

```
        [电源]
          |
     ─────┼─────        ← 主干（高BC，连接多个分支）
     |    |    |
    [A]  [B]  [C]
     |         |
    [D]       [E]        ← 末梢（低BC，只连一个负荷）
```

**骨干线路断了**（如连接电源的那条）：
- ✗ 大量负荷失电（孤立负荷大）
- ✓ 但优化器可以打开联络开关从另一条馈线转供
- ✓ MESS移动储能可以开过去供电
- ✓ VSC换流器可以从DC网络反向输送功率
- ✓ 微电网可以岛运行
- → **虽然影响范围大，但缓解手段多，加固收益反而没那么夸张**

**末梢线路断了**（如连接单个负荷D）：
- ✗ 只影响D
- ✗ 没有替代路径（真正的"死胡同"）
- ✗ MESS未必能到达
- → **影响范围小，但完全无法缓解，加固是唯一出路**

### 这在算法中怎么体现？

```
                    骨干线路                          末梢线路
                    (is_critical=True)                (is_critical=False)
                         |                                |
            连通性模型算出来的                    连通性模型算出来的
            "理论最大收益"很大                    "理论最大收益"较小
                         |                                |
            但优化器会利用转供等手段               优化器没什么手段
            实际收益远小于理论值                   实际收益≈理论值
                         |                                |
            → 所以我们不用连通性上限               → 取 (拓扑归因 + 连通性) / 2
            → 只用拓扑归因（下界）                    作为预测值
```

**用一句话概括**：骨干线路的"纸面影响"很大，但优化器能靠转供/储能/VSC等手段缓解大部分损失，所以实际加固收益不如纸面数字；末梢线路的"纸面影响"就是真实影响（无替代方案）。

---

## 算法三层架构

对每条线路，我们计算三个估计值：

### 第一层：拓扑加权比例归因（下界）

```
对每个台风场景:
  1. 计算每条线路的"加权故障时长" = 故障时间 × 拓扑权重(BC + 孤立负荷比例)
  2. 该线路的归因份额 = 它的加权故障时长 / 所有线路的加权故障时长之和
  3. 该场景中该线路的责任失负荷 = 总失负荷 × 份额
  
最终: Σ(场景概率 × 责任失负荷) / 基线总失负荷 = 改善率
```

**直觉**：失负荷是所有故障线路共同造成的，按"谁故障时间长、谁拓扑位置重要"来分配责任。

### 第二层：XGBoost分位数回归反事实（数据驱动补充）

```
1. 输入特征: 35列线路状态(0/1) + 5列拓扑聚合特征
   (故障线路BC之和、孤立负荷之和、最大BC、最大孤立负荷、故障数量)
2. 目标: 预测每小时的失负荷值
3. 训练XGBoost (用Q90分位数，即关注极端场景)
4. 预测:
   - 原始状态 → 预测失负荷 y_actual
   - 反事实(该线路设为1) → 预测失负荷 y_cf
   - 差异 = y_actual - y_cf = 加固该线路的收益
```

### 第三层：连通性物理模型（上界）

```
对每个台风场景的每个时间步:
  1. 按当前故障模式构建networkx图
  2. 计算所有与电源断开的负荷节点的总负荷(MVA) = 孤立负荷
  3. 假设该线路不故障，重新计算孤立负荷
  4. 差值 = 加固该线路能减少的理论最大孤立负荷
```

### 集成策略

| 线路类型 | 判据 | 使用方法 | 原因 |
|---------|------|---------|------|
| 关键瓶颈线路 | BC>0.08 或 孤立负荷>20% | 拓扑加权归因 | 优化器缓解手段多，连通性模型严重高估 |
| 普通分支线路 | 其他 | avg(拓扑归因, 连通性) | 缓解空间有限，实际在两者之间 |

### 超时节点改善率（over2h）

独立于失负荷，用**图连通性 + Julia基线校准**：

```
1. 对每个场景逐时间步模拟：跟踪每个节点的连续断电时长
2. 连续断电 > 2小时(3个时间步) → 标记为"违规"
3. MESS可达节点：连续断电到2步时MESS到达，重置计数（启发式）
4. 基线的图模型概率 vs Julia概率 → 得到校准系数 α
5. 反事实比率: predicted_cf = julia_base × (graph_cf / graph_base)
```

### 最终综合得分

$$\text{综合改善率} = 0.6 \times \text{失负荷改善率} + 0.4 \times \text{超时改善率}$$

按综合改善率降序排列 → 维修优先级。

---

## 为什么不只看故障次数？

故障次数高不等于加固收益高：
- 一条线路可能经常故障，但每次都能通过转供恢复 → 加固收益小
- 另一条线路可能偶尔故障，但一旦故障就无法恢复 → 加固收益大

这就是为什么我们要用拓扑结构（BC、孤立负荷）来加权，而不是简单计数。

---

## 验证方式

推理层预测是"快但不精确"的近似，Julia MILP优化是"慢但精确"的Ground Truth。

```
推理预测 (Python, ~3秒/条): predict_single_line()
     ↕ 对比误差
Julia验证 (Julia MILP, ~8分钟/条): dispatch_main.jl
```

workflow:
1. 推理层对35条线路全部预测排序（~2分钟）
2. 对排名Top-N条线路跑Julia验证（N × 8分钟）
3. 对比预测vs真实，评估推理精度
